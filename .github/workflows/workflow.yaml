



name: E2E and build testing.

# Controls when the action will run. Triggers the workflow on push or pull request
# events but only for the develop and master branches
on:
  pull_request:
    branches: [develop]

env:
  NODE_VERSION: 22.x
  FRONTEND_SDK_KEY: sdk-frontend-${{ github.sha }}-${{ github.run_id }}-${{ github.run_attempt }}

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  resolve_dep:
    runs-on: ubuntu-latest
    outputs:
      FACTORY_TAG: ${{ steps.resolve_rep.outputs.FACTORY_TAG }}

    steps:
      - name: Resolve required repositories
        id: resolve_rep
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
        run: |
          # this assumes the result is an array, and .name property is used
          check_feature() {
            # first param is the branch, everything after is endpoint for curl
            local branch=$1
            local found=0
            shift
            for endpoint in $@; do
              local json=$(curl -s $endpoint)
              local branch_found=$(echo $json | jq -c ".[] | select(.name==\"$branch\") | .name")
              # to track what we found
              >&2 echo "$endpoint -> $branch_found"
              if [[ $branch_found != "" ]]; then
                found=$((found += 1))
              fi
            done
            echo $found
          }

          FACTORY_TAGS=$(check_feature ${{ github.head_ref }} \
            https://api.github.com/repos/UserOfficeProject/user-office-factory/branches?per_page=100
          )

          TAG_TO_CHECK="${GITHUB_HEAD_REF:-${GITHUB_REF_NAME}}"

          echo "Checking if GHCR tag '$TAG_TO_CHECK' exists"
          if gh api \
            -H "Accept: application/vnd.github+json" \
            --paginate \
            /orgs/userofficeproject/packages/container/user-office-factory/versions \
            | jq -e --arg TAG "$TAG_TO_CHECK" '.[] | select(.metadata.container.tags[]? == $TAG)' > /dev/null; then
            CHECK_IF_IMAGE_EXISTS=true
          else
            CHECK_IF_IMAGE_EXISTS=false
          fi

          echo "CHECK_IF_IMAGE_EXISTS=$CHECK_IF_IMAGE_EXISTS"

          if [[ $CHECK_IF_IMAGE_EXISTS == true ]]; then
              FACTORY_TAGS=$((FACTORY_TAGS+1))
          fi

          if [[ $CHECK_IF_IMAGE_EXISTS == null  ]]; then 
              FACTORY_TAGS=$((FACTORY_TAGS+1))
          fi

          FACTORY_TAG=develop
          if [[ $FACTORY_TAGS == "2" ]]; then
            FACTORY_TAG="${{ github.head_ref }}"
          fi

          echo "FACTORY_TAG=${FACTORY_TAG}" >> $GITHUB_OUTPUT

      - name: Resolved
        run: |
          echo "FACTORY_TAG: ${{ steps.resolve_rep.outputs.FACTORY_TAG }}"

  install-and-cache:
    name: Run install and cache
    needs: resolve_dep
    runs-on: ubuntu-latest

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache node_modules
        id: cached-node-modules-root
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-root-${{ hashFiles('package-lock.json') }}-${{ env.NODE_VERSION }}

      - name: Install root dependencies
        if: steps.cached-node-modules-root.outputs.cache-hit != 'true'
        # We use --ignore-scripts flag to ignore the postinstall script which is actually installing dependencies in all other apps.
        # Caution! The option --ignore-scripts disables ALL scripts - even from the dependencies. If the dependencies need to run scripts to e.g. install some binaries they may break / be incomplete. For now this works and if we experience some issues we can try to find better solution.
        run: npm ci --ignore-scripts

      - name: Cache backend node_modules
        id: cached-node-modules-backend
        uses: actions/cache@v4
        with:
          path: apps/backend/node_modules
          key: node-modules-backend-${{ hashFiles('apps/backend/package-lock.json') }}-${{ env.NODE_VERSION }}

      - name: Install backend dependencies
        if: steps.cached-node-modules-backend.outputs.cache-hit != 'true'
        run: npm run install:backend

      - name: Cache UOWS
        id: cached-UOWS
        uses: actions/cache@v4
        with:
          path: apps/backend/generated
          key: uows-client-${{ hashFiles('apps/backend/openapi.yaml') }}-${{ env.NODE_VERSION }}

      - name: Generate backend UOWS
        if: steps.cached-UOWS.outputs.cache-hit != 'true'
        run: |
          cd apps/backend
          npm run generate:uows

      - name: Cache frontend node_modules
        id: cached-node-modules-frontend
        uses: actions/cache@v4
        with:
          path: apps/frontend/node_modules
          key: node-modules-frontend-${{ hashFiles('apps/frontend/package-lock.json') }}-${{ env.NODE_VERSION }}

      - name: Install frontend dependencies
        if: steps.cached-node-modules-frontend.outputs.cache-hit != 'true'
        run: npm run install:frontend

      - name: Cache frontend SDK
        id: cached-sdk-frontend
        uses: actions/cache@v4
        with:
          path: apps/frontend/src/generated
          key: ${{ env.FRONTEND_SDK_KEY }}

      - name: Generate frontend SDK
        run: |
          cp apps/frontend/example.development.env apps/frontend/.env
          npm run generate:sdk

  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    needs: install-and-cache

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore node_modules
        id: cached-node-modules-root
        uses: actions/cache@v4
        with:
          path: node_modules
          key: node-modules-root-${{ hashFiles('package-lock.json') }}-${{ env.NODE_VERSION }}

      - name: Restore backend node_modules
        id: cached-node-modules-backend
        uses: actions/cache@v4
        with:
          path: apps/backend/node_modules
          key: node-modules-backend-${{ hashFiles('apps/backend/package-lock.json') }}-${{ env.NODE_VERSION }}

      - name: Restore backend UOWS
        id: cached-UOWS
        uses: actions/cache@v4
        with:
          path: apps/backend/generated
          key: uows-client-${{ hashFiles('apps/backend/openapi.yaml') }}-${{ env.NODE_VERSION }}

      - name: Restore frontend node_modules
        id: cached-node-modules-frontend
        uses: actions/cache@v4
        with:
          path: apps/frontend/node_modules
          key: node-modules-frontend-${{ hashFiles('apps/frontend/package-lock.json') }}-${{ env.NODE_VERSION }}

      - name: Restore frontend SDK
        id: cached-sdk-frontend
        uses: actions/cache@v4
        with:
          path: apps/frontend/src/generated
          key: ${{ env.FRONTEND_SDK_KEY }}
          restore-keys: |
            ${{ env.FRONTEND_SDK_KEY }}
            sdk-frontend-

      - run: npm ci
      
      - run: npm run build
        env:
          NODE_ENV: development
          JWT_SECRET: ${{secrets.secret}}
          JWT_TOKEN_LIFE: 7d
          SPARKPOST_TOKEN: wrong_token_for_test

  test_backend:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Restore backend node_modules
        id: cached-node-modules-backend
        uses: actions/cache@v4
        with:
          path: apps/backend/node_modules
          key: node-modules-backend-${{ hashFiles('apps/backend/package-lock.json') }}-${{ env.NODE_VERSION }}
      
      - name: Restore backend UOWS
        id: cached-UOWS
        uses: actions/cache@v4
        with:
          path: apps/backend/generated
          key: uows-client-${{ hashFiles('apps/backend/openapi.yaml') }}-${{ env.NODE_VERSION }}

      - name: Run backend unit tests
        env:
          TZ: Europe/Stockholm
          DATE_FORMAT: dd-MM-yyyy
          DATE_TIME_FORMAT: dd-MM-yyyy HH:mm
          PING_PUBLIC_CRT: dummypingsecret
          DEPENDENCY_CONFIG: e2e
          JWT_SECRET: dummysecret
          NODE_ENV: development
          JWT_TOKEN_LIFE: 7d
          SPARKPOST_TOKEN: dummytoken
          DATABASE_URL: postgres://duouser:duopassword@127.0.0.1:5432/duo
        run: |
          REPO_DIR_NAME=$(basename $GITHUB_WORKSPACE)

          npm run test:backend




  choose_runners:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.make.outputs.matrix }}
    steps:
      - name: Get idle runner count (repo-level)
        id: get
        env:
          OWNER: ${{ github.repository_owner }}
          AUTH: ${{ secrets.GH_API_TOKEN != '' && secrets.GH_API_TOKEN || github.token }}
        run: |
          set -euo pipefail
          REPO="${GITHUB_REPOSITORY#*/}"

          RESPONSE="$(
            curl -sS --fail \
              -H "Authorization: Bearer $AUTH" \
              "https://api.github.com/repos/$OWNER/$REPO/actions/runners?per_page=100"
          )"

          IDLE="$(echo "$RESPONSE" | jq '
            [ (.runners // [])[]?
              | select(.status == "online" and (.busy | not))
              | select([.labels[]?.name] | index("self-hosted") and index("Linux") and index("X64"))
            ] | length
          ')"
          echo "idle=$IDLE" >> "$GITHUB_OUTPUT"

      - name: Build merged matrix (pattern + assigned runner)
        id: make
        run: |
          set -euo pipefail
          N="${{ steps.get.outputs.idle }}"

          # Define your letter pattern buckets (order matters!)
          MATRIX="$(jq -nc --argjson n "$N" '
            # patterns in the order you want to assign self-hosted first
            $patterns := [
              {id:"ae",            files:"cypress/e2e/[a-e]*.ts"},
              {id:"fh",            files:"cypress/e2e/[f-h]*.ts"},
              {id:"io",            files:"cypress/e2e/[i-o]*.ts"},
              {id:"p-am",          files:"cypress/e2e/p[a-m]*.ts"},
              {id:"p-nz",          files:"cypress/e2e/p[n-z]*.ts"},
              {id:"rs",            files:"cypress/e2e/[r-s]*.ts"},
              {id:"t",             files:"cypress/e2e/t!(emplateDeleteAndArchive).ts"},
              {id:"templateDelete",files:"cypress/e2e/templateDeleteAndArchive*.ts"},
              {id:"uz",            files:"cypress/e2e/[u-z]*.ts"},
              {id:"AZ",            files:"cypress/e2e/[A-Z]*.ts"}
            ];

            # cap n to array length
            $n_eff := (if $n < 0 then 0 elif $n > ($patterns|length) then ($patterns|length) else $n end);

            # merge: first $n_eff get self, the rest github
            [ range(0; ($patterns|length))
              | ($patterns[.]) + { runner: (if . < $n_eff then "self" else "github" end) }
            ]
          ')"

          echo "matrix=$MATRIX" >> "$GITHUB_OUTPUT"
          echo "Matrix: $MATRIX"

  e2e:
    needs: [choose_runners]
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.choose_runners.outputs.matrix) }}
    # Map runner key â†’ actual runs-on
    runs-on: ${{ fromJSON( matrix.runner == 'self' && '["self-hosted","Linux","X64"]' || '"ubuntu-latest"' ) }}
    steps:
      - run: |
          echo "Runner: ${{ matrix.runner }}"
          echo "Pattern id: ${{ matrix.id }}"
          echo "Files: ${{ matrix.files }}"
          echo "Hostname: $(hostname)"
      # Example: actually run your tests with the selected files
      # - run: npm run test:e2e -- "${{ matrix.files }}"
